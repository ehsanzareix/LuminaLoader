name: Release (changesets)

on:
  push:
    branches: [main]

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - name: Disable commit hooks
        run: git config core.hooksPath /dev/null
      - name: Create Release pull request or detect publishing needs
        id: changesets
        uses: changesets/action@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Verify NPM token
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc
          if ! npm whoami >/dev/null 2>&1; then
            echo "NPM_TOKEN invalid or expired. Please rotate the token in repository secrets and retry."
            npm whoami || true
            exit 1
          fi
      - name: Publish unpublished packages (custom)
        if: steps.changesets.outputs.hasChangesets == 'false'
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          node <<'NODE'
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');

          function compareVersions(a,b){
            const pa = (a||'0.0.0').split('.').map(s=>parseInt(s.replace(/[^0-9].*/,'')||'0',10)||0);
            const pb = (b||'0.0.0').split('.').map(s=>parseInt(s.replace(/[^0-9].*/,'')||'0',10)||0);
            for(let i=0;i<3;i++){ if(pa[i]>pb[i]) return 1; if(pa[i]<pb[i]) return -1; }
            return 0;
          }

          try{
            execSync('git remote set-url origin https://github.com/ehsanzareix/LuminaLoader.git');
            console.log('Set origin to HTTPS');
          }catch(e){
            console.warn('Could not set origin URL:', e.message);
          }

          const pkg = JSON.parse(fs.readFileSync('package.json','utf8'));
          const workspaces = pkg.workspaces || [];

          for (const w of workspaces) {
            const base = w.replace('/*','');
            if (!fs.existsSync(base)) continue;
            const dirs = fs.readdirSync(base, {withFileTypes:true}).filter(d=>d.isDirectory()).map(d=>path.join(base,d.name));
            for (const d of dirs) {
              const pjson = JSON.parse(fs.readFileSync(path.join(d,'package.json'),'utf8'));
              const localVersion = pjson.version || '0.0.0';
              const name = pjson.name;
              let registryVersion = null;
              try {
                let out = execSync(`npm view ${name} version --json`, {stdio:['pipe','pipe','pipe']}).toString().trim();
                out = out.replace(/^"|"$/g,'');
                if (out) registryVersion = out;
              } catch (e) {
                registryVersion = null; // not found or other error
              }

              if (registryVersion) {
                console.log(`Registry version for ${name} is ${registryVersion}, local is ${localVersion}`);
                if (compareVersions(registryVersion, localVersion) >= 0) {
                  console.log('Skipping publish for', name, '- registry has same or newer version');
                  continue;
                }
              }

              try {
                console.log('Publishing', name);
                execSync('npm publish --access public', { cwd: d, stdio: 'inherit' });
              } catch (e) {
                const m = e && (e.stderr && e.stderr.toString()) || (e && e.message) || '';
                if (m.includes('You cannot publish over the previously published versions') || m.includes('403')) {
                  console.log('Already published, skipping', name);
                  continue;
                }
                console.warn('Publish failed for', name, e && e.message);
                throw e;
              }
            }
          }
          NODE
      - name: Build release notes (custom)
        if: steps.changesets.outputs.hasChangesets == 'false'
        id: build_release
        run: |
          node <<'NODE'
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');
          const pkg = JSON.parse(fs.readFileSync('package.json','utf8'));
          const workspaces = pkg.workspaces || [];
          const published = [];

          function compareVersions(a,b){
            const pa = (a||'0.0.0').split('.').map(s=>parseInt(s.replace(/[^0-9].*/,'')||'0',10)||0);
            const pb = (b||'0.0.0').split('.').map(s=>parseInt(s.replace(/[^0-9].*/,'')||'0',10)||0);
            for(let i=0;i<3;i++){ if(pa[i]>pb[i]) return 1; if(pa[i]<pb[i]) return -1; }
            return 0;
          }

          for (const w of workspaces) {
            const base = w.replace('/*','');
            if (!fs.existsSync(base)) continue;
            const dirs = fs.readdirSync(base, {withFileTypes:true}).filter(d=>d.isDirectory()).map(d=>path.join(base,d.name));
            for (const d of dirs) {
              const pjson = JSON.parse(fs.readFileSync(path.join(d,'package.json'),'utf8'));
              const name = pjson.name;
              try {
                let out = execSync(`npm view ${name} version --json`, {stdio:['pipe','pipe','pipe']}).toString().trim();
                out = out.replace(/^"|"$/g,'');
                if (out) {
                  published.push({name,version: out});
                }
              } catch (e) {
                // not published
              }
            }
          }

          if (published.length === 0) {
            console.log('No packages published, skipping GitHub release creation');
            console.log('::set-output name=tag::');
            console.log('::set-output name=notes::');
            process.exit(0);
          }

          // pick highest version
          let highest = '0.0.0';
          for (const p of published) {
            if (compareVersions(p.version, highest) > 0) highest = p.version;
          }
          const tag = 'v' + highest;
          let notes = `Published packages:\n\n`;
          for (const p of published) notes += `- ${p.name}@${p.version}\n`;
          notes += `\nAutomated release created by workflow.`;
          console.log(`::set-output name=tag::${tag}`);
          console.log(`::set-output name=notes::${notes}`);
          NODE
      - name: Check if release tag exists
        id: check_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          tag=${{ steps.build_release.outputs.tag }}
          # If no tag, set exists=false and continue (no release to create)
          if [ -z "$tag" ]; then
            echo "exists=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          resp=$(curl -s -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${{ github.repository }}/releases/tags/$tag")
          if echo "$resp" | grep -q '"id":'; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub release
        if: steps.changesets.outputs.hasChangesets == 'false' && steps.build_release.outputs.tag != '' && steps.check_release.outputs.exists == 'false'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.build_release.outputs.tag }}
          release_name: ${{ steps.build_release.outputs.tag }}
          body: ${{ steps.build_release.outputs.notes }}
          draft: false
          prerelease: false
